using System.Collections.Generic;
using System.IO;
using System.Linq;
using Dung.Ninja;
using Dung.Ninja.Objects;
using Serilog;
using YamlDotNet.RepresentationModel;

namespace Dung.Lib
{
    /// <summary>
    ///     A project represents a final artifact the project builds, and is intended for the user to use (i.e. executables).
    /// </summary>
    public abstract class Project : IDependency
    {
        /// <summary>
        ///     Create a new Project instance.
        /// </summary>
        /// <param name="rootDir">
        ///     Root directory of the project. Optionally contains a configuration file `project.yml`.
        /// </param>
        /// <param name="sourceDir">
        ///     Directory containing all sources of the project. By convention, recursively all
        ///     matching files in this folder are source files, unless explicitly excluded in the configuration, or
        ///     explicitly included.
        ///     By default, this is `[root]/src`.
        /// </param>
        /// <param name="buildDir">
        ///     Build directory of the project. By default, this is `[root]/build` unless
        ///     the project is used as dependency of another, in which case it is `[root project]/build/[dependency path]`.
        /// </param>
        protected Project(string rootDir, string sourceDir, string buildDir)
        {
            BuildDir = buildDir;
            Log.Information("Project dir: {@string}", rootDir);
            Log.Information("Source dir : {@string}", sourceDir);
            Log.Information("Build dir  : {@string}", buildDir);
            if (!Directory.Exists(BuildDir)) Directory.CreateDirectory(BuildDir);
            string projectFile = Path.Join(rootDir, "project.yml");
            Variables = new Dictionary<string, string>();
            Name = Path.GetFileName(rootDir);

            if (!File.Exists(projectFile)) return;
            Log.Information($"Found configuration file at {projectFile}");
            using var reader = File.OpenText(projectFile);
            var yaml = new YamlStream();
            yaml.Load(reader);
            Configuration = yaml.Documents[0];

            if (!(Configuration.RootNode is YamlMappingNode node)) return;
            var nodeName = new YamlScalarNode("name");
            if (!node.Children.ContainsKey(nodeName)) return;
            Name = node.Children[nodeName].ToString();
        }

        /// <summary>
        ///     Dictionary of top-level variables in the resulting `build.ninja` file, to be used by rules.
        /// </summary>
        public Dictionary<string, string> Variables { get; set; }

        /// <summary>
        ///     Configuration object, parsed as a tree of <see cref="YamlDotNet" /> parser nodes. This configuration file
        ///     is intentionally free-form to allow plugins to use this file for their configuration.
        /// </summary>
        protected YamlDocument? Configuration { get; }

        /// <summary>
        ///     The entry point is the root dependency object that will be built, and referenced if other projects depend on
        ///     this.
        /// </summary>
        protected abstract IDependency Entrypoint { get; }

        /// <summary>
        ///     Path to the build directory.
        /// </summary>
        public string BuildDir { get; }

        /// <inheritdoc />
        public string Name { get; }


        /// <inheritdoc />
        public IEnumerable<IDependency>? Dependencies => new[]
        {
            Entrypoint
        };

        /// <inheritdoc />
        public IEnumerable<IDependency> FlattenDependencies()
        {
            return Dependencies.Concat(Dependencies.SelectMany(d => d.FlattenDependencies()));
        }

        /// <summary>
        ///     Writes the project build configuration into `[build dir]/build.ninja`.
        /// </summary>
        public void WriteNinja()
        {
            var ninjaFile = Path.Join(BuildDir, "build.ninja");
            using var stream = File.Create(ninjaFile);
            using var streamWriter = new StreamWriter(stream) {AutoFlush = true};
            WriteNinja(streamWriter);
            Log.Information("Ninja file written at {@string}", ninjaFile);
        }

        /// <summary>
        ///     Writes the project build configuration into the given <see cref="StreamWriter" />.
        /// </summary>
        /// <param name="writer">Writer stream on which the build configuration will be built.</param>
        public void WriteNinja(StreamWriter writer)
        {
            List<IBuildable> buildables = FlattenDependencies().OfType<IBuildable>().ToList();

            var ninja = new NinjaSyntax(writer);
            ninja.Comment(
                "This file was generated by the dung build system. Please do not edit, as changes will be automatically overriden.");

            ninja.Newline();
            ninja.Comment("Global variables");
            foreach ((string key, string value) in Variables) ninja.Variable(key, value);

            ninja.Newline();
            ninja.Comment("Build rules");
            foreach (Rule rule in buildables.Select(b => b.Rule).ToHashSet(new Rule.Comparer())) ninja.Rule(rule);

            ninja.Newline();
            ninja.Comment("Build artifacts");
            foreach (Build build in buildables.Select(b => b.GetBuild()).ToHashSet(new Build.Comparer()))
                ninja.Build(build);


            if (!(Entrypoint is IBuildable buildable)) return;
            ninja.Newline();
            ninja.Comment("Default artifact to build when invoked directly (without parameters)");
            ninja.Default(buildable.GetBuild());
        }
    }
}